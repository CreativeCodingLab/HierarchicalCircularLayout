 <!DOCTYPE html>
<meta charset="utf-8">
<style>

.node circle {
  cursor: pointer;
  stroke: #3182bd;
  stroke-width: .1px;
  fill-opacity:0.8;
}

.node text {
  font: 10px sans-serif;
  pointer-events: none;
  text-anchor: middle;
}

line.link {
  fill: none;
  stroke: #9ecae1;
  stroke-width: 1px;
}

.node:hover,
.node--source,
.node--target {
  font-weight: 700;
}

.node--source {
  fill: #2ca02c;
}

.node--target {
  fill: #d62728;
}

.link--source,
.link--target {
  stroke-opacity: 1;
  stroke-width: 2px;
}

.link--source {
  stroke: #d62728;
}

.link--target {
  stroke: #2ca02c;
}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script type='text/javascript' src="http://bost.ocks.org/mike/fisheye/fisheye.js?0.0.3"> </script>
<script>

var width = 1200,
    height = 750,
    root;

var force = d3.layout.force()
    .linkDistance(50)
    .charge(-120)
    .gravity(.15)
    .size([width, height])
    .on("tick", tick);

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

var link = svg.selectAll(".link"),
    node_selection = svg.selectAll(".node"); // Empty selection at first
var nodeEnter;
//d3.json("Pro-caspase 8_Nested.json", function(error, json) {
//d3.json("data/3-Rb-E2FpathwayReactome_Nested.json", function(error, json) {
//d3.json("data/52_ERBB2_Nested.json", function(error, json) {
//  d3.json("data/Carnivora2.json", function(error, json) {
  
d3.json("../data/flare.json", function(error, json) {
//d3.json("../data/readme-flare-imports.json", function(error, json) {
  root = json;
  update();
});


time =0;
function update() {
  var nodes = flatten(root), // Got our data
      links = d3.layout.tree().links(nodes);
      tree_nodes = d3.layout.tree().nodes(root);
 

  // debugger;

  // Restart the force layout.
    force
       .nodes(nodes)
       .links(links)
        .start();

  var tree = d3.layout.tree().size([ width, height ]);
  
  tree.sort(comparator);
  //tree.sort(comparator2);
  
  function comparator(a, b) {
    return b.order2 - a.order2;
  }
  
  function nodeSize(d) {
  return d.children ? Math.sqrt(d.children.length) // expanded package
      : 1; // leaf node
  }  
  
  
  count1 = childCount1(0, root); 
  console.log(" count1 = "+count1);

  count2 = childCount2(0, root); 
  root.order1 =0;

  if (time==0){
    var newNodes = tree(root)
      .map(function(d,i) {
        if (d.depth==0){
           d.treeX = 600; 
           d.treeY = 0;//getRadius(root);
           d.alpha = Math.PI/2; 
        }
        /*else if (d.depth==1){
          xP = d.parent.treeX;
          yP = d.parent.treeY;
          aP = d.parent.alpha;
          radius2 = 200;
          d.treeX = xP+radius2*Math.cos(i/(2*d.parent.children.length)*Math.PI/8 -Math.PI*0.9); 
          d.treeY = yP+radius2*Math.sin(i/(2*d.parent.children.length)*Math.PI/8 -Math.PI*0.9); 
        }*/
        if (d.children){
          var totalRadius = 0;
          var totalAngle = Math.PI;
          d.children.forEach(function(child) {
            totalRadius+=getRadius(child);
          });  
          //console.log("totalRadius="+totalRadius);
    
          var begin=d.alpha-totalAngle/2;
          d.children.forEach(function(child,i2) {
            xC =  d.treeX;
            yC =  d.treeY;
            rC = getRadius(d)+getRadius(child)/2;

            //if (d.depth==2)
            //  console.log("node = "+d.name +d.parent.children.indexOf(d)+ " d.parent.alpha="+d.parent.alpha);
             
            var additional = totalAngle*(getRadius(child)/totalRadius);
            //console.log(begin + "    additional = "+additional);
            child.alpha = begin+additional/2;
            begin +=additional;
            
            child.treeX = xC+rC*Math.cos(child.alpha); 
            child.treeY = yC+rC*Math.sin(child.alpha); 
          });
        }


        return d;
    });
  }  
  time++;

  force.nodes(newNodes);

  force.links(links);

  force.start();

  // Update links.
  link = link.data(links, function(d) { return d.target.id; });

  link.exit().remove();

  link.enter().insert("line", ".node")
      .attr("class", "link");

  // Update nodes.
  node_selection = svg.selectAll(".node").data(nodes, function(d) { return d.id; });

  node_selection.exit().remove();

  nodeEnter = node_selection.enter().append("g")
      .attr("class", "node")
      .on("click", click)
      .call(force.drag);

  nodeEnter.append("circle")
      .attr("class", "node")
      .attr("r", getRadius)
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
    
   nodes.forEach(function(d,i) {
  //  d.id =root.childCount1-i;
    console.log("  d.name="+d.name+" id="+d.id);
  });

/*
var bundle = d3.layout.bundle();

var line = d3.svg.line.radial()
    .interpolate("bundle")
    .tension(.85)
    .radius(function(d) { return d.y; })
    .angle(function(d) { return d.x / 180 * Math.PI; });

    svg.selectAll(".link")
      .data(bundle(links))
    .enter().append("path")
      .attr("class", "link")
      .attr("d", line);*/


  //nodeEnter.append("text")
   //   .attr("dy", ".35em")
    //  .text(function(d) { return d.name; });

  node_selection.select("circle")
      .style("fill", color);

  node = svg.selectAll("circle.node");
}
  
      

var fisheye = d3.fisheye.circular()
      .radius(200);
svg.on("mousemove", function() {
  force.stop();
  fisheye.focus(d3.mouse(this));
  d3.selectAll("circle").each(function(d) { d.fisheye = fisheye(d); })
    .attr("cx", function(d) { return d.fisheye.x; })
    .attr("cy", function(d) { return d.fisheye.y; });
   // .attr("r", function(d) { return d.fisheye.z * 8; });
  link.attr("x1", function(d) { return d.source.fisheye.x; })
    .attr("y1", function(d) { return d.source.fisheye.y; })
    .attr("x2", function(d) { return d.target.fisheye.x; })
    .attr("y2", function(d) { return d.target.fisheye.y; });
});

function collide(alpha) {
  var quadtree = d3.geom.quadtree(tree_nodes);
  return function(d) {
    quadtree.visit(function(quad, x1, y1, x2, y2) {
    if (quad.point && (quad.point !== d) && (quad.point !== d.parent) && (quad.point.parent !== d)) {
         var rb = getRadius(d) + getRadius(quad.point),
        nx1 = d.x - rb,
        nx2 = d.x + rb,
        ny1 = d.y - rb,
        ny2 = d.y + rb;

        var x = d.x - quad.point.x,
            y = d.y - quad.point.y,
            l = Math.sqrt(x * x + y * y);
          if (l < rb) {
          l = (l - rb) / l * alpha;
          d.x -= x *= l;
          d.y -= y *= l;
          quad.point.x += x;
          quad.point.y += y;
        }
      }
      return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
    });
  };
}





function tick(event) {
  link.attr("x1", function(d) { return d.source.x; })
    .attr("y1", function(d) { return d.source.y; })
    .attr("x2", function(d) { return d.target.x; })
    .attr("y2", function(d) { return d.target.y; });
  

    node.each(collide(0.8)); //Added 
 
  var force_influence = 0.9;
  node_selection
    .each(function(d) {
      d.x += (d.treeX - d.x) * (force_influence); //*event.alpha;
      d.y += (d.treeY - d.y) * (force_influence); //*event.alpha;
    });
   node.attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });  

   

}

function color(d) {
  return d._children ? "#3182bd" // collapsed package
    : d.children ? "#999999" // expanded package
    : "#bb0055"; // leaf node
}
function getRadius(d) {
return d._children ? 5*Math.pow(d.childCount1, 0.6)// collapsed package
      : d.children ? 5*Math.pow(d.childCount1, 0.6) // expanded package
      : Math.pow(d.size,0.20); // leaf node
}

function childCount1(level, n) {
    count = 0;
    if(n.children && n.children.length > 0) {
      count += n.children.length;
      n.children.forEach(function(d) {
        count += childCount1(level + 1, d);
      });
      n.childCount1 = count;
    }
    else{
       n.childCount1 = 0;
    }
    return count;
};

function childCount2(level, n) {
    var arr = [];
    if(n.children && n.children.length > 0) {
      n.children.forEach(function(d) {
        childCount2(level + 1, d);
        arr.push(d);
      });
    }
    arr.sort(function(a,b) { return parseFloat(a.childCount1) - parseFloat(b.childCount1) } );
    var arr2 = [];
    arr.forEach(function(d, i) {
        d.order1 = i;
        arr2.splice(arr2.length/2,0, d);
    });
    arr2.forEach(function(d, i) {
        d.order2 = i;
    });

};

// Toggle children on click.
function click(d) {
  if (d3.event.defaultPrevented) return; // ignore drag
  if (d.children) {
    d._children = d.children;
    d.children = null;
  } else {
    d.children = d._children;
    d._children = null;
  }
  update();
}

// Lazily construct the package hierarchy from class names.
function packageHierarchy(classes) {
  var map = {};

  function find(name, data) {
    var node = map[name], i;
    if (!node) {
      node = map[name] = data || {name: name, children: []};
      if (name.length) {
        node.parent = find(name.substring(0, i = name.lastIndexOf(".")));
        node.parent.children.push(node);
        node.key = name.substring(i + 1);
      }
    }
    return node;
  }

  classes.forEach(function(d) {
    find(d.name, d);
  });

  return map[""];
}


// Returns a list of all nodes under the root.
function flatten(root) {
  var nodes = [], i = 0;

  function recurse(node) {
    if (node.children) node.children.forEach(recurse);
    if (!node.id) node.id = ++i;
    nodes.push(node);
  }

  recurse(root);
  return nodes;
}
</script>